/** * Binds watchers on object (obj) properies. Callbacks will fire when value of the property changes. * Works on nested objects (see example 'Basic usage'). Can be called on the same object as many times as needed, * but new watchers will replace old watchers on the same property of object (see example 'Multiple call'). * @example <caption>Basic usage.</caption> * var someObject = { * a: 1, * b: ['one','two'], * c: { *         ca: 1 *     } * }; * * function consoleLogger(propName, oldPropValue, newPropValue){ * // this is a points to parent object of property which is changed *     $.writeln('Property ('+ propName +') changed, was: ' + oldPropValue.toString() + ', become: ' + newPropValue.toString()); * } * * function anotherWatcher(propName, oldPropValue, newPropValue){ *  // do something else * } *  * var observable = { * a: [consoleLogger,anotherWatcher], * b: consoleLogger, * c: { *     ca: consoleLogger *     } * }; * * beholder(someObject,observable); * * someObject.a = 99; * //Property (a) changed, was: 1, become: 99 * * someObject.b.push('three'); * // nothing happens!! * // but, if * * someObject.b = ['one','two', 'three']; * // Property (b) changed, was: ['one','two'], become: ['one','two', 'three'] * * @example <caption>Multiple call</caption> * * var something = {a:1, b:'text'}; * * // asume that we have consoleLogger and anotherWatcher from example above * * beholder(something, {a: consoleLogger}); * * something.a = 32; * something.b = 'BIG text'; * * //Property (a) changed, was: 1, become: 32 *  *  * beholder(something, {a: anotherWatcher, b: consoleLogger}); * * something.a = 64; * something.b = 'small text'; * * // anotherWatcher replace the consoleLogger and fires on "a" change * //Property (b) changed, was: 'text', become: 'BIG text' *  * @param {object} obj            - on wich properties spy on. * @param {object} observableList - describes wich of properties changes should be handled and how * * @return {object} Returns obj */module.exports = function beholder(obj, observableList) {    for (var observablePropName in observableList) {        if (observablePropName in obj) {            var propertyValue = obj[observablePropName];            var propertyWatchers = observableList[observablePropName];            if (propertyValue.__class__ === 'Object' && propertyWatchers.__class__ === 'Object') {                beholder(propertyValue, propertyWatchers);            } else {                if (propertyWatchers.__class__ === 'Function') {                    propertyWatchers = [propertyWatchers];                }                if (propertyWatchers.__class__ === 'Array') {                    (function(prop, propertyWatchers) {                        obj.watch(prop, function(propName, oldProp, newProp) {                            propertyWatchers.forEach(function(watcher) {                                if (watcher.__class__ === 'Function') {                                    watcher.apply(this, [propName, oldProp, newProp]);                                }                            }, this);                            /*                            for (var i = 0; i < propertyWatchers.length; i++) {                                var watcher = propertyWatchers[i];                                if (watcher.__class__ === 'Function') {                                    watcher.apply(this, [propName, oldProp, newProp]);                                }                            }                            */                            return newProp;                        });                    })(observablePropName, propertyWatchers);                }            }        }    }    return obj;}